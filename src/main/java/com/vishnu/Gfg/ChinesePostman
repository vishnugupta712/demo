//TC O(n^3)
//SC O(n^2)
public static int chinesePostman(int n, int[][] edges) {
    final int INF = (int)1e9;

    // STEP 1: Build dist matrix + degree arrays
    int[][] dist = new int[n][n];
    for (int i = 0; i < n; i++) {
        Arrays.fill(dist[i], INF);
        dist[i][i] = 0;
    }

    int[] in = new int[n];
    int[] out = new int[n];

    int baseCost = 0;

    for (int[] e : edges) {
        int u = e[0] - 1, v = e[1] - 1, w = e[2];

        out[u]++;
        in[v]++;
        baseCost += w;

        dist[u][v] = Math.min(dist[u][v], w); // shortest direct edge
    }

    // STEP 2: Floyd-Warshall for all-pairs shortest paths
    for (int k = 0; k < n; k++)
        for (int i = 0; i < n; i++)
            for (int j = 0; j < n; j++)
                dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);

    // STEP 3: Collect nodes needing balancing
    List<Integer> pos = new ArrayList<>(); // out > in
    List<Integer> neg = new ArrayList<>(); // in > out

    List<Integer> posCnt = new ArrayList<>();
    List<Integer> negCnt = new ArrayList<>();

    for (int i = 0; i < n; i++) {
        int diff = out[i] - in[i];
        if (diff > 0) {
            pos.add(i);
            posCnt.add(diff);
        } else if (diff < 0) {
            neg.add(i);
            negCnt.add(-diff);
        }
    }

    // STEP 4: Greedy match shortest connections
    int extra = 0;

    for (int i = 0; i < pos.size(); i++) {
        int u = pos.get(i);
        int needU = posCnt.get(i);

        for (int j = 0; j < neg.size() && needU > 0; j++) {
            int v = neg.get(j);
            int needV = negCnt.get(j);

            int flow = Math.min(needU, needV);

            extra += flow * dist[u][v];

            needU -= flow;
            needV -= flow;

            posCnt.set(i, needU);
            negCnt.set(j, needV);
        }
    }

    return baseCost + extra;
}
